{
    "repository_url": "https://github.com/chrisdten3/charts",
    "files": [
      {
        "file_name": "README.md",
        "document_type": "md",
        "content": "# Welcome to charts! A financial personal project on exploring portfolios!\nVisiting the site - https://charts-app-rpxz.onrender.com/\n",
        "file_url": "https://github.com/chrisdten3/charts/blob/main/README.md"
      },
      {
        "file_name": "README.md",
        "document_type": "md",
        "content": "# Welcome to charts! A financial personal project on exploring portfolios!\nVisiting the site - https://charts-app-rpxz.onrender.com/\n",
        "file_url": "https://github.com/chrisdten3/charts/blob/main/README.md"
      },
      {
        "file_name": "app.py",
        "document_type": "py",
        "content": "from flask import Flask, request, jsonify, render_template\nfrom flask_cors import CORS\nfrom efCalc import get_portfolio_allocations\nfrom efCalc import get_history\nfrom efCalc import get_stock_data\n\napp = Flask(__name__)\nCORS(app)\n\n@app.route(\"/api/portfolio\", methods=[\"GET\"])\ndef get_portfolio():\n    tickers = request.args.get(\"tickers\")\n    tickers = tickers.split(\",\")\n    #tickers = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA']\n    max_sharpe_portfolio, min_vol_portfolio = get_portfolio_allocations(tickers)\n\n    return jsonify({\n        \"max_sharpe_portfolio\": max_sharpe_portfolio,\n        \"min_vol_portfolio\": min_vol_portfolio\n    })\n\n@app.route(\"/api/history\", methods=[\"GET\"])\ndef get_stock_history():\n    ticker = request.args.get(\"ticker\")\n    history = get_history(ticker)\n\n    return history\n\n@app.route(\"/api/stock\", methods=[\"GET\"])\ndef get_stock():\n    ticker = request.args.get(\"ticker\")\n    info = get_stock_data(ticker)\n\n    return info\n\n\nif __name__ == \"__main__\":\n    app.run(host='0.0.0.0', port=8000)\n",
        "file_url": "https://github.com/chrisdten3/charts/blob/main/app.py"
      },
      {
        "file_name": "efCalc.py",
        "document_type": "py",
        "content": "import yfinance as yf\nimport pandas as pd  \nimport numpy as np\nimport json\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport scipy.optimize as sco\n\nnp.random.seed(777)\n\ndef get_stock_data(symbol):\n    stock = yf.Ticker(symbol)\n    today_open = stock.history(period=\"1d\")['Open'][0]\n\n    news = stock.news\n    top_3_news = sorted(news, key=lambda x: x['providerPublishTime'], reverse=True)[:3]\n\n    output = {\n        \"symbol\": symbol,\n        \"today_open\": today_open,\n        \"news\": top_3_news\n    }\n\n    return json.dumps(output)\n\ndef get_history(symbol):\n    name = yf.Ticker(symbol)\n    ticker = name.history(period=\"1y\")\n\n    ticker.index = pd.to_datetime(ticker.index)\n\n    ticker['Date'] = ticker.index\n\n    if not {'Date', 'Open', 'High', 'Low', 'Close'}.issubset(ticker.columns):\n        raise ValueError(\"DataFrame must contain 'Date', 'Open', 'High', 'Low', 'Close' columns\")\n    \n\n    series_data = []\n\n    for index,row in ticker.iterrows():\n        timestamp = int(row['Date'].timestamp() * 1000)\n        open_price = row['Open']\n        high_price = row['High']\n        low_price = row['Low']\n        close_price = row['Close']\n        \n        series_data.append([timestamp, open_price, high_price, low_price, close_price])\n    \n    output = {\n        \"series\": [{\n            \"data\": series_data\n        }]\n    }\n    \n    return json.dumps(output)\n\n\ndef get_portfolio_allocations(tickers, period=\"1y\", num_portfolios=25000, risk_free_rate=0.0515):\n    # Grab data for multiple tickers\n    data = yf.download(tickers, period=period)[\"Close\"]\n    returns = data.pct_change()\n    mean_returns = returns.mean()\n    cov_matrix = returns.cov()\n\n    def portfolio_annualised_performance(weights, mean_returns, cov_matrix):\n        returns = np.dot(mean_returns, weights) * 252\n        std = np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights))) * np.sqrt(252)\n        return std, returns\n\n    weights_record = np.random.random((num_portfolios, len(tickers)))\n    weights_record /= weights_record.sum(axis=1)[:, np.newaxis]\n\n    portfolio_std_devs = np.zeros(num_portfolios)\n    portfolio_returns = np.zeros(num_portfolios)\n\n    for i in range(num_portfolios):\n        portfolio_std_devs[i], portfolio_returns[i] = portfolio_annualised_performance(\n            weights_record[i], mean_returns, cov_matrix\n        )\n\n    sharpe_ratios = (portfolio_returns - risk_free_rate) / portfolio_std_devs\n\n    max_sharpe_idx = np.argmax(sharpe_ratios)\n    min_vol_idx = np.argmin(portfolio_std_devs)\n\n    max_sharpe_allocation = {data.columns[i]: round(weight * 100, 2) for i, weight in enumerate(weights_record[max_sharpe_idx])}\n    min_vol_allocation = {data.columns[i]: round(weight * 100, 2) for i, weight in enumerate(weights_record[min_vol_idx])}\n\n    max_sharpe_portfolio = {\n        \"Annualised Return\": round(portfolio_returns[max_sharpe_idx], 2),\n        \"Annualised Volatility\": round(portfolio_std_devs[max_sharpe_idx], 2),\n        \"Allocation\": max_sharpe_allocation\n    }\n\n    min_vol_portfolio = {\n        \"Annualised Return\": round(portfolio_returns[min_vol_idx], 2),\n        \"Annualised Volatility\": round(portfolio_std_devs[min_vol_idx], 2),\n        \"Allocation\": min_vol_allocation\n    }\n\n    return max_sharpe_portfolio, min_vol_portfolio\n\n",
        "file_url": "https://github.com/chrisdten3/charts/blob/main/efCalc.py"
      },
      {
        "file_name": "server.js",
        "document_type": "js",
        "content": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\nconst port = 5011;\n\napp.get('/stock-data', async (req, res) => {\n  try {\n    const apiKey = 'L3F6TGY1X7ZYVGYN';\n    const symbols = [\"AAPL\", \"AMZN\", \"MSFT\", \"GOOGL\", \"TSLA\"];\n    const promises = symbols.map(symbol => {\n      const url = `https://www.alphavantage.co/query?function=TIME_SERIES_WEEKLY&symbol=${symbol}&apikey=${apiKey}`;\n      return axios.get(url);\n    });\n\n    // Wait for all requests to complete\n    const responses = await Promise.all(promises);\n\n    // Check if all requests were successful\n    const errors = responses.filter(response => response.status !== 200);\n    if (errors.length > 0) {\n      console.log('Errors:', errors.map(error => error.status));\n      return res.status(500).send('Error fetching data');\n    }\n\n    // Extract data from responses\n    const data = responses.map(response => response.data);\n\n    // Data is successfully fetched for all symbols\n    res.json(data);\n  } catch (error) {\n    console.error('Error:', error.message);\n    res.status(500).send('Internal Server Error');\n  }\n});\n\napp.listen(port, () => {\n  console.log(`Example app listening on port ${port}`);\n});\n\n\n",
        "file_url": "https://github.com/chrisdten3/charts/blob/main/server.js"
      },
      {
        "file_name": "tailwind.config.js",
        "document_type": "js",
        "content": "/** @type {import('tailwindcss').Config} */\nmodule.exports = {\n  content: [\"./src/**/*.{html,js}\"],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n}\n\n",
        "file_url": "https://github.com/chrisdten3/charts/blob/main/tailwind.config.js"
      },
      {
        "file_name": "app.py",
        "document_type": "py",
        "content": "from flask import Flask, request, jsonify, render_template\nfrom flask_cors import CORS\nfrom efCalc import get_portfolio_allocations\nfrom efCalc import get_history\nfrom efCalc import get_stock_data\n\napp = Flask(__name__)\nCORS(app)\n\n@app.route(\"/api/portfolio\", methods=[\"GET\"])\ndef get_portfolio():\n    tickers = request.args.get(\"tickers\")\n    tickers = tickers.split(\",\")\n    #tickers = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA']\n    max_sharpe_portfolio, min_vol_portfolio = get_portfolio_allocations(tickers)\n\n    return jsonify({\n        \"max_sharpe_portfolio\": max_sharpe_portfolio,\n        \"min_vol_portfolio\": min_vol_portfolio\n    })\n\n@app.route(\"/api/history\", methods=[\"GET\"])\ndef get_stock_history():\n    ticker = request.args.get(\"ticker\")\n    history = get_history(ticker)\n\n    return history\n\n@app.route(\"/api/stock\", methods=[\"GET\"])\ndef get_stock():\n    ticker = request.args.get(\"ticker\")\n    info = get_stock_data(ticker)\n\n    return info\n\n\nif __name__ == \"__main__\":\n    app.run(host='0.0.0.0', port=8000)\n",
        "file_url": "https://github.com/chrisdten3/charts/blob/main/app.py"
      },
      {
        "file_name": "efCalc.py",
        "document_type": "py",
        "content": "import yfinance as yf\nimport pandas as pd  \nimport numpy as np\nimport json\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport scipy.optimize as sco\n\nnp.random.seed(777)\n\ndef get_stock_data(symbol):\n    stock = yf.Ticker(symbol)\n    today_open = stock.history(period=\"1d\")['Open'][0]\n\n    news = stock.news\n    top_3_news = sorted(news, key=lambda x: x['providerPublishTime'], reverse=True)[:3]\n\n    output = {\n        \"symbol\": symbol,\n        \"today_open\": today_open,\n        \"news\": top_3_news\n    }\n\n    return json.dumps(output)\n\ndef get_history(symbol):\n    name = yf.Ticker(symbol)\n    ticker = name.history(period=\"1y\")\n\n    ticker.index = pd.to_datetime(ticker.index)\n\n    ticker['Date'] = ticker.index\n\n    if not {'Date', 'Open', 'High', 'Low', 'Close'}.issubset(ticker.columns):\n        raise ValueError(\"DataFrame must contain 'Date', 'Open', 'High', 'Low', 'Close' columns\")\n    \n\n    series_data = []\n\n    for index,row in ticker.iterrows():\n        timestamp = int(row['Date'].timestamp() * 1000)\n        open_price = row['Open']\n        high_price = row['High']\n        low_price = row['Low']\n        close_price = row['Close']\n        \n        series_data.append([timestamp, open_price, high_price, low_price, close_price])\n    \n    output = {\n        \"series\": [{\n            \"data\": series_data\n        }]\n    }\n    \n    return json.dumps(output)\n\n\ndef get_portfolio_allocations(tickers, period=\"1y\", num_portfolios=25000, risk_free_rate=0.0515):\n    # Grab data for multiple tickers\n    data = yf.download(tickers, period=period)[\"Close\"]\n    returns = data.pct_change()\n    mean_returns = returns.mean()\n    cov_matrix = returns.cov()\n\n    def portfolio_annualised_performance(weights, mean_returns, cov_matrix):\n        returns = np.dot(mean_returns, weights) * 252\n        std = np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights))) * np.sqrt(252)\n        return std, returns\n\n    weights_record = np.random.random((num_portfolios, len(tickers)))\n    weights_record /= weights_record.sum(axis=1)[:, np.newaxis]\n\n    portfolio_std_devs = np.zeros(num_portfolios)\n    portfolio_returns = np.zeros(num_portfolios)\n\n    for i in range(num_portfolios):\n        portfolio_std_devs[i], portfolio_returns[i] = portfolio_annualised_performance(\n            weights_record[i], mean_returns, cov_matrix\n        )\n\n    sharpe_ratios = (portfolio_returns - risk_free_rate) / portfolio_std_devs\n\n    max_sharpe_idx = np.argmax(sharpe_ratios)\n    min_vol_idx = np.argmin(portfolio_std_devs)\n\n    max_sharpe_allocation = {data.columns[i]: round(weight * 100, 2) for i, weight in enumerate(weights_record[max_sharpe_idx])}\n    min_vol_allocation = {data.columns[i]: round(weight * 100, 2) for i, weight in enumerate(weights_record[min_vol_idx])}\n\n    max_sharpe_portfolio = {\n        \"Annualised Return\": round(portfolio_returns[max_sharpe_idx], 2),\n        \"Annualised Volatility\": round(portfolio_std_devs[max_sharpe_idx], 2),\n        \"Allocation\": max_sharpe_allocation\n    }\n\n    min_vol_portfolio = {\n        \"Annualised Return\": round(portfolio_returns[min_vol_idx], 2),\n        \"Annualised Volatility\": round(portfolio_std_devs[min_vol_idx], 2),\n        \"Allocation\": min_vol_allocation\n    }\n\n    return max_sharpe_portfolio, min_vol_portfolio\n\n",
        "file_url": "https://github.com/chrisdten3/charts/blob/main/efCalc.py"
      },
      {
        "file_name": "README.md",
        "document_type": "md",
        "content": "# Welcome to charts! A financial personal project on exploring portfolios!\nVisiting the site - https://charts-app-rpxz.onrender.com/\n",
        "file_url": "https://github.com/chrisdten3/charts/blob/main/README.md"
      },
      {
        "file_name": "app.py",
        "document_type": "py",
        "content": "from flask import Flask, request, jsonify, render_template\nfrom flask_cors import CORS\nfrom efCalc import get_portfolio_allocations\nfrom efCalc import get_history\nfrom efCalc import get_stock_data\n\napp = Flask(__name__)\nCORS(app)\n\n@app.route(\"/api/portfolio\", methods=[\"GET\"])\ndef get_portfolio():\n    tickers = request.args.get(\"tickers\")\n    tickers = tickers.split(\",\")\n    #tickers = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA']\n    max_sharpe_portfolio, min_vol_portfolio = get_portfolio_allocations(tickers)\n\n    return jsonify({\n        \"max_sharpe_portfolio\": max_sharpe_portfolio,\n        \"min_vol_portfolio\": min_vol_portfolio\n    })\n\n@app.route(\"/api/history\", methods=[\"GET\"])\ndef get_stock_history():\n    ticker = request.args.get(\"ticker\")\n    history = get_history(ticker)\n\n    return history\n\n@app.route(\"/api/stock\", methods=[\"GET\"])\ndef get_stock():\n    ticker = request.args.get(\"ticker\")\n    info = get_stock_data(ticker)\n\n    return info\n\n\nif __name__ == \"__main__\":\n    app.run(host='0.0.0.0', port=8000)\n",
        "file_url": "https://github.com/chrisdten3/charts/blob/main/app.py"
      },
      {
        "file_name": "efCalc.py",
        "document_type": "py",
        "content": "import yfinance as yf\nimport pandas as pd  \nimport numpy as np\nimport json\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport scipy.optimize as sco\n\nnp.random.seed(777)\n\ndef get_stock_data(symbol):\n    stock = yf.Ticker(symbol)\n    today_open = stock.history(period=\"1d\")['Open'][0]\n\n    news = stock.news\n    top_3_news = sorted(news, key=lambda x: x['providerPublishTime'], reverse=True)[:3]\n\n    output = {\n        \"symbol\": symbol,\n        \"today_open\": today_open,\n        \"news\": top_3_news\n    }\n\n    return json.dumps(output)\n\ndef get_history(symbol):\n    name = yf.Ticker(symbol)\n    ticker = name.history(period=\"1y\")\n\n    ticker.index = pd.to_datetime(ticker.index)\n\n    ticker['Date'] = ticker.index\n\n    if not {'Date', 'Open', 'High', 'Low', 'Close'}.issubset(ticker.columns):\n        raise ValueError(\"DataFrame must contain 'Date', 'Open', 'High', 'Low', 'Close' columns\")\n    \n\n    series_data = []\n\n    for index,row in ticker.iterrows():\n        timestamp = int(row['Date'].timestamp() * 1000)\n        open_price = row['Open']\n        high_price = row['High']\n        low_price = row['Low']\n        close_price = row['Close']\n        \n        series_data.append([timestamp, open_price, high_price, low_price, close_price])\n    \n    output = {\n        \"series\": [{\n            \"data\": series_data\n        }]\n    }\n    \n    return json.dumps(output)\n\n\ndef get_portfolio_allocations(tickers, period=\"1y\", num_portfolios=25000, risk_free_rate=0.0515):\n    # Grab data for multiple tickers\n    data = yf.download(tickers, period=period)[\"Close\"]\n    returns = data.pct_change()\n    mean_returns = returns.mean()\n    cov_matrix = returns.cov()\n\n    def portfolio_annualised_performance(weights, mean_returns, cov_matrix):\n        returns = np.dot(mean_returns, weights) * 252\n        std = np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights))) * np.sqrt(252)\n        return std, returns\n\n    weights_record = np.random.random((num_portfolios, len(tickers)))\n    weights_record /= weights_record.sum(axis=1)[:, np.newaxis]\n\n    portfolio_std_devs = np.zeros(num_portfolios)\n    portfolio_returns = np.zeros(num_portfolios)\n\n    for i in range(num_portfolios):\n        portfolio_std_devs[i], portfolio_returns[i] = portfolio_annualised_performance(\n            weights_record[i], mean_returns, cov_matrix\n        )\n\n    sharpe_ratios = (portfolio_returns - risk_free_rate) / portfolio_std_devs\n\n    max_sharpe_idx = np.argmax(sharpe_ratios)\n    min_vol_idx = np.argmin(portfolio_std_devs)\n\n    max_sharpe_allocation = {data.columns[i]: round(weight * 100, 2) for i, weight in enumerate(weights_record[max_sharpe_idx])}\n    min_vol_allocation = {data.columns[i]: round(weight * 100, 2) for i, weight in enumerate(weights_record[min_vol_idx])}\n\n    max_sharpe_portfolio = {\n        \"Annualised Return\": round(portfolio_returns[max_sharpe_idx], 2),\n        \"Annualised Volatility\": round(portfolio_std_devs[max_sharpe_idx], 2),\n        \"Allocation\": max_sharpe_allocation\n    }\n\n    min_vol_portfolio = {\n        \"Annualised Return\": round(portfolio_returns[min_vol_idx], 2),\n        \"Annualised Volatility\": round(portfolio_std_devs[min_vol_idx], 2),\n        \"Allocation\": min_vol_allocation\n    }\n\n    return max_sharpe_portfolio, min_vol_portfolio\n\n",
        "file_url": "https://github.com/chrisdten3/charts/blob/main/efCalc.py"
      },
      {
        "file_name": "server.js",
        "document_type": "js",
        "content": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\nconst port = 5011;\n\napp.get('/stock-data', async (req, res) => {\n  try {\n    const apiKey = 'L3F6TGY1X7ZYVGYN';\n    const symbols = [\"AAPL\", \"AMZN\", \"MSFT\", \"GOOGL\", \"TSLA\"];\n    const promises = symbols.map(symbol => {\n      const url = `https://www.alphavantage.co/query?function=TIME_SERIES_WEEKLY&symbol=${symbol}&apikey=${apiKey}`;\n      return axios.get(url);\n    });\n\n    // Wait for all requests to complete\n    const responses = await Promise.all(promises);\n\n    // Check if all requests were successful\n    const errors = responses.filter(response => response.status !== 200);\n    if (errors.length > 0) {\n      console.log('Errors:', errors.map(error => error.status));\n      return res.status(500).send('Error fetching data');\n    }\n\n    // Extract data from responses\n    const data = responses.map(response => response.data);\n\n    // Data is successfully fetched for all symbols\n    res.json(data);\n  } catch (error) {\n    console.error('Error:', error.message);\n    res.status(500).send('Internal Server Error');\n  }\n});\n\napp.listen(port, () => {\n  console.log(`Example app listening on port ${port}`);\n});\n\n\n",
        "file_url": "https://github.com/chrisdten3/charts/blob/main/server.js"
      },
      {
        "file_name": "tailwind.config.js",
        "document_type": "js",
        "content": "/** @type {import('tailwindcss').Config} */\nmodule.exports = {\n  content: [\"./src/**/*.{html,js}\"],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n}\n\n",
        "file_url": "https://github.com/chrisdten3/charts/blob/main/tailwind.config.js"
      },
      {
        "file_name": "server.js",
        "document_type": "js",
        "content": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\nconst port = 5011;\n\napp.get('/stock-data', async (req, res) => {\n  try {\n    const apiKey = 'L3F6TGY1X7ZYVGYN';\n    const symbols = [\"AAPL\", \"AMZN\", \"MSFT\", \"GOOGL\", \"TSLA\"];\n    const promises = symbols.map(symbol => {\n      const url = `https://www.alphavantage.co/query?function=TIME_SERIES_WEEKLY&symbol=${symbol}&apikey=${apiKey}`;\n      return axios.get(url);\n    });\n\n    // Wait for all requests to complete\n    const responses = await Promise.all(promises);\n\n    // Check if all requests were successful\n    const errors = responses.filter(response => response.status !== 200);\n    if (errors.length > 0) {\n      console.log('Errors:', errors.map(error => error.status));\n      return res.status(500).send('Error fetching data');\n    }\n\n    // Extract data from responses\n    const data = responses.map(response => response.data);\n\n    // Data is successfully fetched for all symbols\n    res.json(data);\n  } catch (error) {\n    console.error('Error:', error.message);\n    res.status(500).send('Internal Server Error');\n  }\n});\n\napp.listen(port, () => {\n  console.log(`Example app listening on port ${port}`);\n});\n\n\n",
        "file_url": "https://github.com/chrisdten3/charts/blob/main/server.js"
      },
      {
        "file_name": "README.md",
        "document_type": "md",
        "content": "# Welcome to charts! A financial personal project on exploring portfolios!\nVisiting the site - https://charts-app-rpxz.onrender.com/\n",
        "file_url": "https://github.com/chrisdten3/charts/blob/main/README.md"
      },
      {
        "file_name": "app.py",
        "document_type": "py",
        "content": "from flask import Flask, request, jsonify, render_template\nfrom flask_cors import CORS\nfrom efCalc import get_portfolio_allocations\nfrom efCalc import get_history\nfrom efCalc import get_stock_data\n\napp = Flask(__name__)\nCORS(app)\n\n@app.route(\"/api/portfolio\", methods=[\"GET\"])\ndef get_portfolio():\n    tickers = request.args.get(\"tickers\")\n    tickers = tickers.split(\",\")\n    #tickers = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA']\n    max_sharpe_portfolio, min_vol_portfolio = get_portfolio_allocations(tickers)\n\n    return jsonify({\n        \"max_sharpe_portfolio\": max_sharpe_portfolio,\n        \"min_vol_portfolio\": min_vol_portfolio\n    })\n\n@app.route(\"/api/history\", methods=[\"GET\"])\ndef get_stock_history():\n    ticker = request.args.get(\"ticker\")\n    history = get_history(ticker)\n\n    return history\n\n@app.route(\"/api/stock\", methods=[\"GET\"])\ndef get_stock():\n    ticker = request.args.get(\"ticker\")\n    info = get_stock_data(ticker)\n\n    return info\n\n\nif __name__ == \"__main__\":\n    app.run(host='0.0.0.0', port=8000)\n",
        "file_url": "https://github.com/chrisdten3/charts/blob/main/app.py"
      },
      {
        "file_name": "efCalc.py",
        "document_type": "py",
        "content": "import yfinance as yf\nimport pandas as pd  \nimport numpy as np\nimport json\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport scipy.optimize as sco\n\nnp.random.seed(777)\n\ndef get_stock_data(symbol):\n    stock = yf.Ticker(symbol)\n    today_open = stock.history(period=\"1d\")['Open'][0]\n\n    news = stock.news\n    top_3_news = sorted(news, key=lambda x: x['providerPublishTime'], reverse=True)[:3]\n\n    output = {\n        \"symbol\": symbol,\n        \"today_open\": today_open,\n        \"news\": top_3_news\n    }\n\n    return json.dumps(output)\n\ndef get_history(symbol):\n    name = yf.Ticker(symbol)\n    ticker = name.history(period=\"1y\")\n\n    ticker.index = pd.to_datetime(ticker.index)\n\n    ticker['Date'] = ticker.index\n\n    if not {'Date', 'Open', 'High', 'Low', 'Close'}.issubset(ticker.columns):\n        raise ValueError(\"DataFrame must contain 'Date', 'Open', 'High', 'Low', 'Close' columns\")\n    \n\n    series_data = []\n\n    for index,row in ticker.iterrows():\n        timestamp = int(row['Date'].timestamp() * 1000)\n        open_price = row['Open']\n        high_price = row['High']\n        low_price = row['Low']\n        close_price = row['Close']\n        \n        series_data.append([timestamp, open_price, high_price, low_price, close_price])\n    \n    output = {\n        \"series\": [{\n            \"data\": series_data\n        }]\n    }\n    \n    return json.dumps(output)\n\n\ndef get_portfolio_allocations(tickers, period=\"1y\", num_portfolios=25000, risk_free_rate=0.0515):\n    # Grab data for multiple tickers\n    data = yf.download(tickers, period=period)[\"Close\"]\n    returns = data.pct_change()\n    mean_returns = returns.mean()\n    cov_matrix = returns.cov()\n\n    def portfolio_annualised_performance(weights, mean_returns, cov_matrix):\n        returns = np.dot(mean_returns, weights) * 252\n        std = np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights))) * np.sqrt(252)\n        return std, returns\n\n    weights_record = np.random.random((num_portfolios, len(tickers)))\n    weights_record /= weights_record.sum(axis=1)[:, np.newaxis]\n\n    portfolio_std_devs = np.zeros(num_portfolios)\n    portfolio_returns = np.zeros(num_portfolios)\n\n    for i in range(num_portfolios):\n        portfolio_std_devs[i], portfolio_returns[i] = portfolio_annualised_performance(\n            weights_record[i], mean_returns, cov_matrix\n        )\n\n    sharpe_ratios = (portfolio_returns - risk_free_rate) / portfolio_std_devs\n\n    max_sharpe_idx = np.argmax(sharpe_ratios)\n    min_vol_idx = np.argmin(portfolio_std_devs)\n\n    max_sharpe_allocation = {data.columns[i]: round(weight * 100, 2) for i, weight in enumerate(weights_record[max_sharpe_idx])}\n    min_vol_allocation = {data.columns[i]: round(weight * 100, 2) for i, weight in enumerate(weights_record[min_vol_idx])}\n\n    max_sharpe_portfolio = {\n        \"Annualised Return\": round(portfolio_returns[max_sharpe_idx], 2),\n        \"Annualised Volatility\": round(portfolio_std_devs[max_sharpe_idx], 2),\n        \"Allocation\": max_sharpe_allocation\n    }\n\n    min_vol_portfolio = {\n        \"Annualised Return\": round(portfolio_returns[min_vol_idx], 2),\n        \"Annualised Volatility\": round(portfolio_std_devs[min_vol_idx], 2),\n        \"Allocation\": min_vol_allocation\n    }\n\n    return max_sharpe_portfolio, min_vol_portfolio\n\n",
        "file_url": "https://github.com/chrisdten3/charts/blob/main/efCalc.py"
      },
      {
        "file_name": "server.js",
        "document_type": "js",
        "content": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\nconst port = 5011;\n\napp.get('/stock-data', async (req, res) => {\n  try {\n    const apiKey = 'L3F6TGY1X7ZYVGYN';\n    const symbols = [\"AAPL\", \"AMZN\", \"MSFT\", \"GOOGL\", \"TSLA\"];\n    const promises = symbols.map(symbol => {\n      const url = `https://www.alphavantage.co/query?function=TIME_SERIES_WEEKLY&symbol=${symbol}&apikey=${apiKey}`;\n      return axios.get(url);\n    });\n\n    // Wait for all requests to complete\n    const responses = await Promise.all(promises);\n\n    // Check if all requests were successful\n    const errors = responses.filter(response => response.status !== 200);\n    if (errors.length > 0) {\n      console.log('Errors:', errors.map(error => error.status));\n      return res.status(500).send('Error fetching data');\n    }\n\n    // Extract data from responses\n    const data = responses.map(response => response.data);\n\n    // Data is successfully fetched for all symbols\n    res.json(data);\n  } catch (error) {\n    console.error('Error:', error.message);\n    res.status(500).send('Internal Server Error');\n  }\n});\n\napp.listen(port, () => {\n  console.log(`Example app listening on port ${port}`);\n});\n\n\n",
        "file_url": "https://github.com/chrisdten3/charts/blob/main/server.js"
      },
      {
        "file_name": "tailwind.config.js",
        "document_type": "js",
        "content": "/** @type {import('tailwindcss').Config} */\nmodule.exports = {\n  content: [\"./src/**/*.{html,js}\"],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n}\n\n",
        "file_url": "https://github.com/chrisdten3/charts/blob/main/tailwind.config.js"
      },
      {
        "file_name": "tailwind.config.js",
        "document_type": "js",
        "content": "/** @type {import('tailwindcss').Config} */\nmodule.exports = {\n  content: [\"./src/**/*.{html,js}\"],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n}\n\n",
        "file_url": "https://github.com/chrisdten3/charts/blob/main/tailwind.config.js"
      }
    ]
  }